<!--(
     "Title": "Staticcheck"
)-->


<h3 id="overview">Overview</h3>

<p>
  Staticcheck is a static analysis toolset for the <a href="https://golang.org">Go programming language.</a>
  It comes with a large number of checks,
  integrates with various Go build systems
  and offers enough customizability to fit into your workflows.
</p>

<h3 id="running-the-tools">Running staticcheck</h3>

<p>
  Staticcheck can be run on code in several ways,
  mimicking the way the official Go tools work.
  At the core, it expects to be run on well-formed Go packages.
  The most common way of specifying packages is via their import paths.
  One or more packages can be specified in a single command,
  and the <code>...</code> glob operator is supported.
  All of the following examples are valid invocations:

  <pre><code>staticcheck github.com/example/foo
staticcheck github.com/example/foo github.com/example/bar
staticcheck github.com/example/...</code></pre>
</p>

<p>
  In addition, a single package can be specified as a list of files:

  <pre><code>staticcheck file1.go file2.go file3.go</code></pre>

  Note that <strong>all</strong> files of the package need to be specified,
  similar to how <code>go build</code> works.
</p>

<h3 id="configuration">Configuration</h3>

<p>
  Various aspects of staticcheck can be customized with configuration files.
</p>

<p>
  These files are placed in Go packages and apply recursively to the package tree rooted at the containing package.
  For example, configuration placed in <code>pkg</code> will apply to <code>pkg</code>, <code>pkg/subpkg</code>, <code>pkg/subpkg/subsubpkg</code> and so on.
</p>

<p>
  Configuration files in subpackages can override or inherit from settings of configuration files higher up the package tree.
  Staticcheck's default configuration is represented as the virtual root of the configuration tree and can be inherited from.
</p>

<h4>Configuration format</h4>

<p>
  Staticcheck configuration files are named <code>staticcheck.conf</code> and contain <a href="https://github.com/toml-lang/toml">TOML</a>.
</p>

<p>
  Any set option will override the same option from further up the package tree,
  whereas unset options will inherit their values.
  Additionally, the special value <code>"inherit"</code> can be used to inherit values.
  This is especially useful for array values, as it allows adding and removing values to the inherited option.
</p>

<p>
  The special value <code>"all"</code> matches all possible values.
  Currently, this is only used when enabling checks.
</p>

<p>
  Values prefixed with a minus sign,
  such as <code>"-S1000"</code>
  will exclude values from a list.
  This can be used in combination with <code>"all"</code> to express "all but",
  or in combination with <code>"inherit"</code> to remove values from the inherited option.
</p>

<h4>Options</h4>

<p>
  A list of all options and their explanations can be found on the <a href="/docs/options">Options</a> page.
</p>

<h4>Example configuration</h4>

<p>
  The following example configuration is the textual representation of staticcheck's default configuration.
</p>

<pre><code>{{ option "checks" }} = ["all", "-{{ check "ST1000" }}", "-{{ check "ST1003" }}", "-{{ check "ST1016" }}"]
{{ option "initialisms" }} = ["ACL", "API", "ASCII", "CPU", "CSS", "DNS",
	"EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID",
	"IP", "JSON", "QPS", "RAM", "RPC", "SLA",
	"SMTP", "SQL", "SSH", "TCP", "TLS", "TTL",
	"UDP", "UI", "GID", "UID", "UUID", "URI",
	"URL", "UTF8", "VM", "XML", "XMPP", "XSRF",
	"XSS"]
{{ option "dot_import_whitelist" }} = []
{{ option "http_status_code_whitelist" }} = ["200", "400", "404", "500"]</code></pre>

<h3 id="cli">Command-line flags</h3>

<p>
  In addition to configuration files, some aspects of staticcheck can be controlled via command-line flags.
  These are settings that can vary between individual invocations or environments (CI, editors, ...) and shouldn't be stored in configuration files.
</p>

<table class="table">
  <tr>
    <th>Flag</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>-checks</td>
    <td>
      Allows overriding the list of checks to run.
      Has the same syntax as the <a href="/docs/options#checks"><code>checks</code></a> setting
      in configuration files.
    </td>
  </tr>
  <tr>
    <td>-explain</td>
    <td>
      Print the description of a check.
    </td>
  </tr>
  <tr>
    <td>-f</td>
    <td>
      Select between the different <a href="/docs/formatters">output formats</a>.
    </td>
  </tr>
  <tr>
    <td>-fail</td>
    <td>
      Specify the list of checks which,
      if they find any issues in your code,
      should cause staticcheck to exit with a non-zero status.
      This can be used, for example, to not fail your CI
      pipeline because of possible code simplifications.
    </td>
  </tr>
  <tr>
    <td>-go</td>
    <td>
      Select the Go version to target.
      See
      <a href="#targeting-go-versions">Targeting Go versions</a>
      for more details.
    </td>
  </tr>
  <tr>
    <td style="white-space: nowrap">-show-ignored</td>
    <td>
      Show all problems found,
      even those that were ignored by linter directives.
    </td>
  </tr>
  <tr>
    <td>-tags</td>
    <td>
      Similar to <code>go build -tags</code>,
      allows specifiying the build tags to use.
    </td>
  </tr>
  <tr>
    <td>-tests</td>
    <td>
      Include tests in the analysis.
    </td>
  </tr>
  <tr>
    <td>-unused.whole-program</td>
    <td>
      Run unused in whole program mode.
    </td>
  </tr>
  <tr>
    <td>-version</td>
    <td>
      Display the version of staticcheck and exit.
    </td>
  </tr>
</table>

<h3 id="targeting-go-versions">Targeting Go versions</h3>

<p>
  By default, staticcheck will make suggestions that are correct for the current version of Go.
  If you're wishing to support older versions of Go,
  not all suggestions are applicable –
  some simplifications are only valid for newer versions of Go
  and deprecated functions may not have had viable alternatives in older versions.
</p>

<p>
  To target a specific Go version you can use the <code>-go</code> command line flag.
  For example, with <code>-go 1.6</code>, only suggestions that are valid for Go 1.6 will be made.
</p>

<h3 id="ignoring-problems">Ignoring problems</h3>

<p>
  In general, you shouldn't have to ignore problems reported by staticcheck.
  Great care is taken to minimize the number of false positives and subjective suggestions.
  Dubious code should be rewritten and genuine false positives should be reported so that they can be fixed.
</p>

<p>
  The reality of things, however, is that not all corner cases can be taken into consideration.
  Sometimes code just has to look weird enough to confuse tools,
  and sometimes suggestions, though well-meant, just aren't applicable.
  For those rare cases, there are several ways of ignoring unwanted problems.
</p>

<h4 id="line-based-linter-directives">Line-based linter directives</h4>

<p>
  The most fine-grained way of ignoring reported problems is to annotate the offending lines of code with linter directives.
</p>

<p>
  The <code>//lint:ignore Check1[,Check2,...,CheckN] reason</code> directive
  ignores one or more checks on the following line of code.
  The <code>reason</code> is a required field
  that must describe why the checks should be ignored for that line of code.
  This field acts as documentation for other people (including future you) reading the code.
</p>

<p>
  Let's consider the following example,
  which intentionally checks that the results of two identical function calls are not equal:

  <pre><code>func TestNewEqual(t *testing.T) {
  if errors.New("abc") == errors.New("abc") {
    t.Errorf(`New("abc") == New("abc")`)
  }
}</code></pre>
</p>

<p>
  {{ check "SA4000" }} of staticcheck
  will flag this code,
  pointing out that the left and right side of <code>==</code> are identical –
  usually indicative of a typo and a bug.
</p>

<p>
  To silence this problem, we can use a linter directive:

  <pre><code>func TestNewEqual(t *testing.T) {
  //lint:ignore SA4000 we want to make sure that no two results of errors.New are ever the same
  if errors.New("abc") == errors.New("abc") {
    t.Errorf(`New("abc") == New("abc")`)
  }
}</code></pre>
</p>

<h5>Maintenance of linter directives</h5>

<p>
  It is crucial to update or remove outdated linter directives when code has been changed.
  Staticcheck helps you with this by making unnecessary directives a problem of its own.
  For example, for this (admittedly contrived) snippet of code

  <pre><code>//lint:ignore SA1000 we love invalid regular expressions!
regexp.Compile(".+")</code></pre>

  staticcheck will report the following:

  <pre><code>tmp.go:1:2: this linter directive didn't match anything; should it be removed?</code></pre>
</p>

<p>
  Checks that have been disabled via configuration files
  will not cause directives to be considered unnecessary.
</p>

<h4 id="file-based-linter-directives">File-based linter directives</h4>

<p>
  In some cases, you may want to disable checks for an entire file.
  For example, code generation may leave behind a lot of unused code,
  as it simplifies the generation process.
  Instead of manually annotating every instance of unused code,
  the code generator can inject a single, file-wide ignore directive to ignore the problem.
</p>

<p>
  File-based linter directives look a lot like line-based ones:

  <pre><code>//lint:file-ignore U1000 Ignore all unused code, it's generated</code></pre>
</p>

<p>
  The only difference is that these comments aren't associated with any specific line of code.
  Conventionally, these comments should be placed near the top of the file.
</p>

<p>
  Unlike line-based directives, file-based ones will not be flagged for being unnecessary.
</p>

<h3 id="resource-usage">Resource usage</h3>

<p>
  Static analysis is a rather resource intensive process,
  having to apply expensive algorithms on a lot of data.
  Depending on the complexity of the checked code,
  this can result in many gigabytes of memory usage and minutes (if not hours) of CPU time.
</p>

<p>
  When using staticcheck, there are two different ways of running it:
  one package per invocation, or many packages per invocation.
  These two modes have opposite CPU and memory usage characteristics.
</p>

<p>
  Checking one package per invocation will keep the memory usage low,
  but may end up recompiling the same packages over and over again, wasting CPU time.
</p>

<p>
  Checking many packages, on the other hand,
  needs to keep more data in memory at once,
  but can reuse compiled packages, saving CPU time.
</p>

<p>
  The following tables will show the characteristics of the different modes.
</p>

<table class="table">
  <caption>Resource consumption in different operation modes</caption>
  <thead>
    <tr>
      <th>Mode</th>
      <th>CPU usage</th>
      <th>Memory usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>One package per invocation</td>
      <td>High</td>
      <td>Low</td>
    </tr>
    <tr>
      <td>Many packages per invocation</td>
      <td>Low</td>
      <td>High</td>
    </tr>
  </tbody>
</table>

<table class="table">
  <caption>Using staticcheck to check the Go standard library</caption>
  <thead>
    <tr>
      <th>Mode</th>
      <th>CPU time spent</th>
      <th>Wall time spent</th>
      <th>Max memory used</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>One package per invocation</td>
      <td>1692%</td>
      <td>2241%</td>
      <td>28%</td>
    </tr>
    <tr>
      <td>All packages in one invocation (reference value)</td>
      <td>100%</td>
      <td>100%</td>
      <td>100%</td>
    </tr>
  </tbody>
</table>

<p>
  The maximum memory usage of a single invocation depends
  on the combined complexity of the checked packages and their dependencies.
  The entire standard library combined requires roughly 2.31 GB of memory,
  while the most complex package, <code>net/http</code>, only needs 640 MB.
  Other packages, such as the tiny <code>image/color/palette</code>, may only need as little as 17 MB.
</p>

<p>
  Checking packages individually reduces both the maximum and the average (over time) memory usage,
  but requires a much greater amount of CPU time,
  as shared dependencies have to be compiled over and over again.
  You should use the method that best suits your available resources.
</p>



<h3>Checks</h3>

A list of all checks can be found on the <a href="/docs/checks">Checks</a> page.
